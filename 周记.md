# 周记

## 1.计划笔记：

- 完成招聘网站的静态页面编写
- 数据库表建立
- 学习ssm内容





## 2.SSM学习笔记：

### 1.Spring

**IoC**：控制反转（Inversion of Control），指的是将创痛编程方式中的程序依赖关系的控制权从程序内部转移到程序外部，允许程序员从程序逻辑中分离出对具体实现的依赖和管理。**（就是解耦：分离调用与实现）**

**依赖注入**：不直接使用具体的实现类，对于程序所依赖的组件往往以忌口的形式出现。**在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件**

#### 

**Spring开发流程**

- 下载Spring开发包

- 导入Spring的jar包

- **配置Spring的核心xml文件**

- 在程序中读取Spring的配置文件来获取**Bean**[Bean其实就是一个new好的对象]

  

```
<bean id="" class="">                         //唯一标识符和其类路径
    <property name="" value=""></property>    //属性名和对应的值
</bean>
```



**spring内部创建对象的原理：**

> 1.解析xml文件，获取类名,id,属性
>
> 2.通过反射，用类型创建对象
>
> 3.给创建的对象赋值
>
> 注：spring的配置文件通常放在src目录下



**装配Bean的三种方式讲解**

**第一种：new实现类**

```
<!--配置一个bean[对象]-->
<bean id="" class=""></bean>
```

**第二种：通过静态工厂方法**

beans.xml配置

```
<bean id="userService2" class="com.cyh.service.IUserServiceFactory1" factory-method="createUserService"></bean>
```

工厂类代码

```
public class IUserServiceFactory1 {
    public static IUserService createUserService(){
        return new IUserServiceImpl();
    }
}
```

**第三种：通过实例工厂方法**

工厂类代码

```
public class IUserServiceFactory {
    public  IUserService createUserService(){
        return new IUserServiceImpl();
    }
}
```

beans.xml配置代码

```
<bean id="factory" class="com.cyh.service.IUserServiceFactory"></bean>
<bean id="userService3" factory-bean="factory" factorymethod="createUserService"></bean>
```

测试类里面的代码

```
@Test
public void test5(){
  ApplicationContext context =
      new ClassPathXmlApplicationContext("com/cyh/bean3.xml");
  IUserService userService2 = (IUserService)context.getBean("userService3");
  userService2.add();
}
```



**Bean的作用域：**

| **singleton** | **在Spring IoC容器中仅存在一个Bean实例，Bean以单例方式存在,默认值。** |
| ------------- | ------------------------------------------------------------ |
| **prototype** | **每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行new XxxBean()。** |

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--单例模式，每次创建的都是同一个对象-->
    <bean id="" class="" 	scope="singleton"></bean>
    <!--多例模式，每次创建的都是不同对象-->
    <bean id="" class="" 	scope="prototype"></bean>
</beans>
```



#### 注解注入

- 注解：就是一个类，使用@注解名称
- 开发中：使用注解 取代 xml配置文件



**@Component注解的使用**：**标准一个普通的spring Bean类**

语法																								解释说明
**@Repository(“名称”)																	   dao层**
**@Service(“名称”)																			 service层**
**@Controller(“名称”)																		web层**
**@Autowired																				    自动根据类型注入**
**@Qualifier(“名称”)																	  	指定自动注入的id名称**
@Resource(“名称”)	
@PostConstruct																			自定义初始化
@PreDestroy	  																			自定义销毁

**注意：默认情况下，spring是不开启注解功能的，需要在beans.xml文件中加上下面两行：（及加入context）**

```
xmlns:context="http://www.springframework.org/schema/context"
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd"
```



**@Resource,@Scope**

@Resource(name=" ")

@Resource(name="")相当于@Autowired和@Qualifier("");



### 2.SpringMVC

**SpringMVC框架简单介绍：**

springmvc是spring框架的一个模块，**springmvc和spring无需通过中间整合层进行整合。**
springmvc是一个**基于mvc的web框架。**
springmvc 表现层：**方便前后端数据的传输**
Spring MVC 拥有控制器，作用跟Struts类似，接收外部请求，解析参数传给服务层
**MVC是指，C控制层，M模块层，V显示层这样的设计理念**，而SSM框架里面SPRING MVC本身就是MVC框架，作用是帮助（某种意义上也可以 理解为约束）我们要按照MVC这样的设计来开发WEB项目。



**Springmvc架构原理解析**:
1.发起请求到前端控制器(DispatcherServlet)
2.前端控制器请求HandlerMapping查找 Handler，可以根据xml配置、注解进行查找
3.处理器映射器HandlerMapping向前端控制器返回Handler
4.前端控制器调用处理器适配器去执行Handler
5.处理器适配器去执行Handler
6.Handler执行完成给适配器返回ModelAndView
7.处理器适配器向前端控制器返回ModelAndView，ModelAndView是springmvc框架的一个底层对象，包括 Model和view
8.前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图(jsp)
9.视图解析器向前端控制器返回View
10.前端控制器进行视图渲染，视图渲染将模型数据(在ModelAndView对象中)填充到request域
11.前端控制器向用户响应结果





**SpringMVC常用注解**
**@Controller**
　　 负责注册一个bean 到spring 上下文中

**@RequestMapping**
　　 注解为控制器指定可以处理哪些 URL 请求

**@RequestBody**
　　 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上 ,再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上

**@ResponseBody**
　　 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区

**@ModelAttribute** 　　　
　　1.在方法定义上使用 @ModelAttribute 注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了@ModelAttribute 的方法
　　2.在方法的入参前使用 @ModelAttribute 注解：可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数 –绑定到对象中，再传入入参将方法入参对象添加到模型中

**@RequestParam**　
　　在处理方法入参处使用 @RequestParam 可以把请求参 数传递给请求方法

**@PathVariable**
　　绑定 URL 占位符到入参
**@ExceptionHandler**
　　注解到方法上，出现异常时会执行该方法
**@ControllerAdvice**
　　使一个Contoller成为全局的异常处理类，类中用@ExceptionHandler方法注解的方法可以处理所有Controller发生的异常









## 最后总结：

刚开始在搭建maven时遇到困难，最后还是后台师兄帮忙解答的。这提醒我下次遇到这种情况时不能直接上csdn去解决，因为里面太杂了，有些还不够完善。还是得跟着视频或者请教别人好一点。然后在学习ssm的时候路程比较艰难，中间来来回回在springboot和ssm之间不知道先学习哪个，因为看到一个视频说可以先学习springboot再返学ssm，于是我也去尝试一下。发现不适合我，笑死。早知道直接学习ssm了。

在做这个考核我目前的想法是边学边做。现在这周主要是学习ssm，以及前期项目先搭建好。比如所使用的数据库表先提前设计好并建立。像登录界面和主界面那些是可以提前先写的。在这周我的界面还没写完，才完成两个。并且还不确定。

对于后面的考核，我的想法是先把ssm和springboot的大概先学完，最起码那些语法会使用。然后再写考核。在写考核的同时不断的修正ssm和springboot的知识体系